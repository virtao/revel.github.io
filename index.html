---
root: .
title: Go语言Web开发框架Revel
---
<!DOCTYPE html>
<html lang="zh">
  <head>
    {% include head.html %}
    <link href="{{ page.root }}/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="{{ page.root }}/js/prettify.js" type="text/javascript"></script>
    <script src="{{ page.root }}/js/lang-go-rich.js" type="text/javascript"></script>
    {% include analytics.html %}
  </head>

  <body onload="prettyPrint()">
    <a href="https://github.com/revel/revel">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index:1000;"
           src="img/forkme_right_orange_ff7600.png" alt="在GitHub上Fork我"></a>

    {% include topnav.html %}

    <header class="hero-unit">
      <div class="container">
        <div class="row" style="margin-left:-50px;">
          <div class="hero-img"><img src="img/RevelWhiteLines.png" height="500" width="350"></div>
          <div class="hero-text">
            <h1>Revel</h1>
            <p>一个Go语言下的高效Web开发框架</p>
          </div>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="page-header">
        <h1>特性</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>热部署</h2>
          <p>
            编辑→保存→刷新。Revel会为你自动编译代码和模板，无需等待。代码没有自动编译？Revel会给你一个
            <a href="img/CompilationError.png">有帮助的信息</a>。
            运行环境崩溃（panic）？Revel <a href="img/Panic.png">完全可以
            处理</a>。
          </p>
        </div>
        <div class="span4">
          <h2>全方位</h2>
          <p>
            Revel 提供
            <a href="manual/routing.html">路由(routing)</a>,
            <a href="manual/binding.html">参数处理(parameter parsing)</a>,
            <a href="manual/validation.html">验证(validation)</a>,
            <a href="manual/sessionflash.html">会话/存储(session/flash)</a>,
            <a href="manual/templates.html">模板(templating)</a>,
            <a href="manual/cache.html">缓存(caching)</a>,
            <a href="manual/jobs.html">任务(job running)</a>,
            <a href="manual/testing.html">测试框架(a testing framework)</a>,
            甚至<a href="manual/i18n-messages.html">国际化(internationalization)</a>.
          </p>
        </div>
        <div class="span4">
          <h2>高性能</h2>
          <p>
            Revel构建在Go的HTTP服务器之上，根据
            <a href="http://www.techempower.com/benchmarks/#section=data-r5">最近
            测试</a>表明，其完全可以应付比Rails高 <b>三到十倍</b> 的
            各类请求负载。
          </p>
        </div>
      </div>
      <div class="page-header">
        <h1>框架设计</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>同步</h2>
          <p>
            <a href="http://golang.org/pkg/net/http/">Go HTTP 服务器</a>
            将每个请求都放在单独的
            <a href="http://golang.org/doc/effective_go.html#goroutines">goroutine</a>中运行。
            可以自由的编写简单的无回调代码。
          </p>
        </div>
        <div class="span4">
          <h2>无状态</h2>
          <p>
            Revel provides primitives that keep the web tier stateless for
            predictable scaling. For example, session data is stored in the user
            cookie, and the cache is backed by a memcached cluster.
          </p>
        </div>
        <div class="span4">
          <h2>模块化</h2>
          <p>
            Revel 由叫做 <b>filters</b> 的中间件构建而成，
            它将几乎所有的请求处理过程模块化。开发者可以任意替换
            默认的filters来实现自己的功能（例如：自定义路由）。
          </p>
        </div>
      </div>
      <div class="row">
      </div>
      <section id="quickstart">
        <div class="page-header">
          <h1>快速入门</h1>
        </div>
        <div class="row">
          <div class="span6">
            <p>
              Revel 提供了一些现实当中使用的示例应用程序。
            </p>
            <p>
              你需要<a href="http://golang.org/doc/install">配置好的Go 1.2
              环境</a> 来运行这些应用。
            </p>
            <p>
              右边的命令的作用是：
              <ol>
                <li>将 Revel 安装到 GOPATH 路径下
                <li>编译 Revel 的命令行工具
                <li>运行一个聊天的示例程序
              </ol>
              运行后，打开浏览器访问
              <a href="http://localhost:9000/">http://localhost:9000/</a>，你也可以
              <a href="samples/chat.html">看看它是怎么运行的</a>。
            </p>
          </div>
          <div class="span6" style="vertical-align:bottom;">
            <pre>
  go get github.com/revel/cmd/revel
  revel run github.com/revel/revel/samples/chat
            </pre>
          </div>
        </div>
      </section>

      <section id="development">
        <div class="page-header">
          <h1>Development Status <small>Early adopters only.  Pull requests welcome.</small></h1>
        </div>
        <p>
          Development is closing in on the "final" 1.0 design, but the rate of
          change is still high. Expect to get your hands dirty.
        </p>
        <p style="font-weight:bold;">
          Join our <a href="https://groups.google.com/forum/#!forum/revel-framework">Google Group</a>
          to take part in the design and development, or in IRC at 
          <a href="http://webchat.freenode.net/?channels=revel&amp;uio=d4">Freenode #revel</a>.
          You may join <a href="https://groups.google.com/group/revel-framework-announce">our
          announcement list</a> to only be notified for new releases.
        </p>
        <p>
          <a href="https://twitter.com/revelframework" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @revelframework</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

          <a href="https://twitter.com/share" class="twitter-share-button" data-via="revelframework" data-size="large" data-count="none" data-hashtags="golang">Tweet</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </p>
      </section>

      <section id="teaser">
        <div class="page-header">
          <h1>Overview</h1>
        </div>
        <p>
          This section gives you a taste of various parts of the framework:
        </p>

        <dl class="dl-horizontal">
          <dt><a href="#routing">Routing</a></dt>
          <dd>A simple declarative routing syntax.  Type-safe reverse routing.</dd>

          <dt><a href="#controllers">Controllers</a></dt>
          <dd>
            Revel organizes endpoints into Controllers. They provide easy
            data binding and form validation.
          </dd>

          <dt><a href="#templates">Templates</a></dt>
          <dd>Revel makes Go Templates simple to use at scale.</dd>

          <dt><a href="#interceptors">Interceptors</a></dt>
          <dd>
            Register functionality to be called before or after actions.  They
            can be activated per Controller.
          </dd>

          <dt><a href="#filters">Filters</a></dt>
          <dd>
            More general functionality can be implemented with Filters.
          </dd>

        </dl>

        <div class="row">
          <div class="span6">
            <h2 id="routing">Routing</h2>
            <p>
              Revel uses a declarative routing syntax. It collects all routes
              for an app in a single file, with a simple syntax for matching
              requests, extracting arguments from URIs, and specifying
              route-specific arguments to the action. Here's a commented
              sample...
            </p>
          </div>
          <div class="span12">
            <pre>
# conf/routes
# This file defines all application routes (Higher priority routes first)
GET    /login                Application.Login       <b># A simple path</b>
GET    /hotels/              Hotels.Index            <b># Matches with or without trailing slash</b>
GET    /hotels/:id           Hotels.Show             <b># Extract an embedded argument</b>
WS     /hotels/:id/feed      Hotels.Feed             <b># WebSockets.</b>
POST   /hotels/:id/:action   Hotels.:action          <b># Automatically route some actions.</b>
GET    /public/*filepath     Static.Serve("public")  <b># Assets served from /public/...</b>
*      /:controller/:action  :controller.:action     <b># Catch all; Automatic URL generation</b></pre>

          </div>
          <div class="span6">
						<p>
							Reverse routes can be generated in a type-safe manner.  For example:
						</p>
          </div>
          <div class="span12">
            <pre class="prettyprint lang-go">
// Show the hotel information.
func (c Hotels) Show(id int) revel.Result {
	hotel := HotelById(id)
	return c.Render(hotel)
}

// Save the updated hotel information and redirect back to Show.
func (c Hotels) Save(hotel Hotel) revel.Result {
	// validate and save hotel
	return c.Redirect(<b>routes.Hotels.Show(hotel.Id)</b>)
}</pre>
					</div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="controllers">Controllers</h2>
            <p>
              All Actions are methods on a Controller.  This teaser shows a couple cool things:
              <ul>
                <li> <b>Data binding.</b>  Revel binds simple values and structs from
                  the URL or form and passes them as parameters to your method.
                  (If you prefer to access them directly from a parameter map, that's ok too!)
                <li> <b>Validation.</b> Helpers to manage validation errors.
                <li> <b>Flash.</b> The flash is a cookie that lives for one
                  request (errors, success messages, etc).
                <li> <b>Session.</b> The session is a cryptographically signed
                  cookie, exposed as a <code>map[string]string</code>.
                <li> <b>Results.</b> Redirections take advantage of reverse
                  routing.  Template rendering makes your data available using the
                  name of the local variable!
              </ul>

              Here's an example:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-go">
// app/controllers/app.go

type Application struct {
	*revel.Controller
}

func (c Application) Register() revel.Result {
	title := "Register"
	return c.Render(title)
}

func (c Application) SaveUser(user models.User, verifyPassword string) revel.Result {
	c.Validation.Required(verifyPassword)
	c.Validation.Required(verifyPassword == user.Password)
		Message("Password does not match")
	user.Validate(c.Validation)

	if c.Validation.HasErrors() {
		c.Validation.Keep()
		c.FlashParams()
		return c.Redirect(routes.Application.Register())
	}

	user.HashedPassword, _ = bcrypt.GenerateFromPassword(
		[]byte(user.Password), bcrypt.DefaultCost)
	err := c.Txn.Insert(&user)
	if err != nil {
		panic(err)
	}

	c.Session["user"] = user.Username
	c.Flash.Success("Welcome, " + user.Name)
	return c.Redirect(routes.Hotels.Index())
}
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="templates">Templates</h2>
            <p>
              By convention, Revel manages to integrate
              <a href="http://golang.org/pkg/text/template/">Go Templates</a>
              easily into the rest of the web app. Here is part of the template
              rendered in the <b>Register</b> action shown above.
            </p>
            Note that:
            <ul>
              <li> Revel found it automatically using the name of the action.
              <li> <b>field</b> is a simple helper function that returns a map
                of validation errors and parameter values for the named field.
                The app may inject any helper funcs that it wants.
              <li> The <b>title</b> variable is available in the template as if
                it had been explicitly put in the RenderArgs.  (It's used in
                <a href="http://github.com/revel/revel/samples/booking/app/views/header.html">
                  header.html</a> in this case)
            </ul>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-html">{% capture teaser_template %}{% raw %}
{{/* app/views/Application/Register.html */}}

{{template "header.html" .}}

<h1>Register:</h1>
<form action="/register" method="POST">
  {{with $field := field "user.Username" .}}
    <p class="{{$field.ErrorClass}}">
      <strong>Username:</strong>
      <input type="text" name="{{$field.Name}}" size="16" value="{{$field.Flash}}"> *
      <span class="error">{{$field.Error}}</span>
    </p>
  {{end}}

  {{/* other fields */}}

  <p class="buttons">
    <input type="submit" value="Register"> <a href="/">Cancel</a>
  </p>
</form>

{{template "footer.html" .}}{% endraw %}{% endcapture %}{{ teaser_template|escape }}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="interceptors">Interceptors</h2>
            <p>
              Interceptors are controller methods that are run before or after
              requests, or in response to panics.  By embedding a controller
              into another, a developer can share interceptors and fields across
              many controllers.
            </p>
						<p>
							As an example, the database module may be used to open a
							connection on initialization, made available through a global
							handle.  Additionally, embedding the <b>db.Transactional</b> type
							adds a <b>sql.Txn</b> field plus interceptors that begin and commit
							transactions (or rollback on panic).
						</p>
						<p>
							Here's what the interceptor looks like (minus error handling):
						</p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/revel/revel/modules/db/app/db.go

var Db *sql.DB

func Init() {
	// Read configuration.
	Driver, _ = revel.Config.String("db.driver")
	Spec, _ = revel.Config.String("db.spec")

	// Open a connection.
	Db, _ = sql.Open(Driver, Spec)
}

// Transactional adds transaction management to your controller.
type Transactional struct {
	*revel.Controller
	Txn *sql.Tx
}

func (c *Transactional) Begin() revel.Result {
	c.Txn, _ = Db.Begin()
	return nil
}

func (c *Transactional) Commit() revel.Result {
	_ = c.Txn.Commit()
	c.Txn = nil
	return nil
}

func (c *Transactional) Rollback() revel.Result {
	_ = c.Txn.Rollback()
	c.Txn = nil
	return nil
}

func init() {
	revel.InterceptMethod((*Transactional).Begin, revel.BEFORE)
	revel.InterceptMethod((*Transactional).Commit, revel.AFTER)
	revel.InterceptMethod((*Transactional).Rollback, revel.PANIC)
}</pre>

						<p>
							Here is how it can be mixed in to an application controller:
						</p>

            <pre class="prettyprint">
type Bookings struct {
	*revel.Controller
	db.Transactional  // Adds .Txn
	user.Login        // Adds .User
}

func (c Bookings) ShowFirstBooking() revel.Result {
	row := c.Txn.QueryRow(`
select id, hotel_id, user_id, price, nights
  from Booking
 where UserId = ?
 limit 1`, c.User.Id)
	...
	return c.Render(booking)
}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="filters">Filters</h2>
            <p>
              Filters are the middleware of the application.  They are simply
              funcs with a specific signature:
            </p>
            <pre class="prettyprint">
type Filter func(c *Controller, filterChain []Filter)</pre>
            <p>
              Even complicated "built-in" functionality like the interceptor
              framework is implemented as a filter:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/revel/revel/intercept.go

var InterceptorFilter = func(c *Controller, fc []Filter) {
	defer invokeInterceptors(FINALLY, c)
	defer func() {
		if err := recover(); err != nil {
			invokeInterceptors(PANIC, c)
			panic(err)
		}
	}()

	// Invoke the BEFORE interceptors and return early, if we get a result.
	invokeInterceptors(BEFORE, c)
	if c.Result != nil {
		return
	}

	fc[0](c, fc[1:])
	invokeInterceptors(AFTER, c)
}</pre>
						<p>
							Revel provides a default stack of Filters which the developer can
							override.  This makes it easy for the developer to select exactly
							the parts of the framework that they want to use.
						</p>

            <pre class="prettyprint">
// github.com/revel/revel/filter.go

// Filters is the default set of global filters.
// It may be set by the application on initialization.
var Filters = []Filter{
	PanicFilter,             // Recover from panics and display an error page instead.
	RouterFilter,            // Use the routing table to select the right Action
	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.
	ParamsFilter,            // Parse parameters into Controller.Params.
	SessionFilter,           // Restore and write the session cookie.
	FlashFilter,             // Restore and write the flash cookie.
	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.
	I18nFilter,              // Resolve the requested language
	InterceptorFilter,       // Run interceptors around the action.
	ActionInvoker,           // Invoke the action.
}
						</pre>

						<p>
							Nearly all framework functionality is implemented in the filters,
							and the filter stack is directly exposed to the developer as part
							of the configuration.  This makes Revel understandable and modular.
						</p>
						<p>
							As proof of modularity, look how simple
							the <a href="https://github.com/revel/revel/blob/master/server.go">
								main server handler</a> is:
						</p>
            <pre class="prettyprint">
// github.com/revel/revel/server.go

func handleInternal(w http.ResponseWriter, r *http.Request, ws *websocket.Conn) {
	var (
		req  = NewRequest(r)
		resp = NewResponse(w)
		c    = NewController(req, resp)
	)
	req.Websocket = ws

	Filters[0](c, Filters[1:])
	if c.Result != nil {
		c.Result.Apply(req, resp)
	}
}</pre>
          </div>
				</div>
      </section>

      <section id="wishlist">
        <div class="page-header">
          <h1>Wishlist</h1>
        </div>
        <p>
          There are some areas that could benefit from some TLC.
        </p>
        <ul>
          <li> <b>ORM</b> -- Presently Revel is BYOORM (bring-your-own-ORM).  A
            good ORM integration would make simple things simple.
            (e.g. <a href="http://github.com/coopernurse/gorp">gorp</a>,
            <a href="https://github.com/eaigner/hood">hood</a>,
            <a href="https://github.com/coocood/qbs">qbs</a>,
            <a href="https://github.com/eaigner/jet">jet</a>,
            <a href="https://github.com/astaxie/beedb">beedb</a>,
            <a href="https://github.com/gosexy/db">gosexy</a>,
            <a href="https://github.com/jinzhu/gorm">gorm</a>)
          <li> <b>Pluggable template loader</b> -- Presently only Go templates
          are supported by Revel (although the developer could use their own
          library independently).  Providing an interface that makes any
          template language pluggable would be ideal.
        </ul>
      </section>

      <hr>

      <footer>
        <p>MIT License</p>
        <p>
          Gopher images remixed from those produced by
          <a href="http://www.golang.org">Go team</a>.
        </p>
      </footer>

    </div> <!-- /container -->
  </body>
</html>
